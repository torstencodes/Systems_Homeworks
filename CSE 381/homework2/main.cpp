
/* 
 * File:   main.cpp
 * Author: Torsten Overbeck
 * Copyright 2020 overbetn@miamioh.edu
 * Created on February 7, 2020, 9:47 AM
 * 
 * Simple program that opens files that provide different Linux user group 
 * information as well as user information. The user then provides group IDs 
 * that they would like to search and the program will return the different 
 * users associated to those groups. 
 */

// Including the necessary libraries for functions used in program.

#include <cstdlib>
#include <string>
#include <iostream>
#include <fstream>
#include <unordered_map>
#include <iomanip> 
#include <sstream>
#include <algorithm>
#include <vector>

// using name spaces and unordered_map to make code more readable

using namespace std;
using maps = std::unordered_map<int, string>;

/* This method prints out groups and users in that group based on the group IDs
 * provided by the user input. The groups that exist use the IDs as keys to an
 * unordered_map that store the each member of that group with their respective
 * user ID. 
 * 
 * @param gID - this is an unordered map that has an integer key 
 * (group ID) with a string value that is the holding all the users and their 
 * respective IDs.
 * 
 * @param inputs - this is a vector of integers that holds the groups IDs that
 * were passed in by the command line arguments. 
 */
void printOut(maps& gID, vector<int>& inputs) {
    for (size_t i = 0; i < inputs.size(); i++) {
        if (gID.find(inputs.at(i)) == gID.end()) {
            cout << inputs.at(i) << " = Group not found." << endl;
        } else {
            cout << inputs.at(i) << " = " << gID[inputs.at(i)] << endl;
        }
    }
}
/* scanGroup method relies on the previous method being called, scanPass, and 
 * uses that map generated by that method combined with the groups file to 
 * generate a map that easily creates our desired output. It maps each key
 * in gID to a string containing the users in that group. It does so using a
 * similar method in scanPass by replacing both the commas and colons with 
 * spaces to make it simple to parse with a string stream.
 * 
 * @param groupIn - the input file stream to access the groups file 
 * 
 * @param gID - a map that maps a group ID to all a string containing all the 
 * users and user IDs in that group.
 * 
 * @param users - a map that maps the user ID to a respective user, makes 
 * setting up the gID map much simpler. 
 */
void scanGroup(ifstream& groupIn, maps& gID, maps& users) {
    std::string groupName, passkey, temp, output;
    int gid, userId;
    while (getline(groupIn, temp)) {
        replace(begin(temp), end(temp), ':', ' ');
        replace(begin(temp), end(temp), ',', ' ');
        istringstream is(temp);
        is >> groupName >> passkey >> gid;
        output = groupName + ": ";
        while (is >> userId) {
            output = output + users[userId] + "(" + to_string(userId) + ") ";
        }
        gID[gid] = output;
    }
}
/* scanPass simply uses a string stream to parse the data coming in from the 
 * passwd file. In order to make it easy to break up with the >> operator
 * the replace method is used to replace any colon with a ' '. Then the user ID
 * is mapped to a user provided by the passwd file. This all happens while the 
 * file stream is still able to get a line. 
 * 
 * @param passIn - a reference to an input file stream for the passwd file.
 * 
 * @param users - is a map of integers (user IDs) mapped to a string (users)
 */
void scanPass(ifstream& passIn, maps& users) {
    std::string user, passkey, temp;
    int uid;
    while (getline(passIn, temp)) {
        replace(begin(temp), end(temp), ':', ' ');
        istringstream is(temp);
        is >> user >> passkey >> uid;
        users[uid] = user;
    }
}
/* This simply opens up the file streams to read from the provided groups and 
 * passwd files. It assumes the files are good and does not check for the case
 * where they are not. Then it creates the respective unordered_maps which are
 * used in the later methods and those methods refer back to these maps. After 
 * that, there is a vector of integers which takes in the command line arguments
 * which represent the groupIDs to be searched for. Lastly, there are three 
 * calls to methods that fill the respective maps and then finally print the 
 * desired output. 
 * 
 * @param argc - provides the number of groups IDs that the user inputs through
 * the command line.
 * 
 * @param argv - an array that stores all of the different group IDs to be 
 * searched for.
 */
int main(int argc, char** argv) {
    ifstream groupIn("groups");
    ifstream passIn("passwd");
    maps gID, users;
    vector<int> inputs;
    for (int i = 1; i < argc; i++) {
        inputs.push_back(stoi(argv[i]));
    }
    scanPass(passIn, users);
    scanGroup(groupIn, gID, users);
    printOut(gID, inputs);
}
